[
  {
    "path": "posts/2019-01-17-events/",
    "title": "Work with event objects",
    "description": "Event objects are a simple way to implement dosing or other interventions\ninto your simulation. They are created with special constructors and elementary\nevents can be combined in different ways to create complex dosing regimens.",
    "author": [],
    "date": "2019-01-17",
    "categories": [
      "events"
    ],
    "contents": "\n\nContents\nIntroduction\nSetup\nEvents\nEvent expectations\nCombine events\nCombine to create a data set\n\nIntroduction\nEvent objects are simple ways to implement PK dosing events into your model simulation.\nSetup\nLet’s illustrate event objects with a one-compartment, PK model. We read this model from the mrgsolve internal model library.\n\nlibrary(mrgsolve)\nlibrary(dplyr)\noptions(mrgsolve.soloc = \"build\")\n\n\nmod <- mread_cache(\"pk1cmt\", modlib(), end=216, delta=0.1)\n\nEvents\nEvents are constructed with the ev function\n\ne <- ev(amt=100, ii=24, addl=6)\n\nThis will implement 100 unit doses every 24 hours for a total of 7 doses. e has class ev, but really it is just a data frame\n\ne\n. Events:\n.   time amt ii addl cmt evid\n. 1    0 100 24    6   1    1\n\n\nas.data.frame(e)\n.   time amt ii addl cmt evid\n. 1    0 100 24    6   1    1\n\nWe can implement this series of doses by passing e in as the events argument to mrgsim()\n\nmod %>% mrgsim(events=e) %>% plot(EV1+CP~time)\n\n\nThe events can also be implemented with the ev constructor along the simulation pipeline\n\nmod %>%\n  ev(amt = 100, ii = 24, addl = 6) %>%\n  mrgsim %>% \n  plot(CP~time)\n\n\nEvent expectations\namt is required\nevid=0 is forbidden\nDefault time is 0\nDefault evid is 1\nDefault cmt is 1\nAlso by default, rate, ss and ii are 0.\nCombine events\nmrgsolve has operators defined that allow you to combine events. Let’s first define some event objects.\n\ne1 <- ev(amt=500)\ne2 <- ev(amt=250, ii=24, addl=4)\ne3 <- ev(amt=500, ii=24, addl=0)\ne4 <- ev(amt=250, ii=24, addl=4, time=24)\n\nWe can combine e1 and e3 with a collection operator\n\nc(e1,e4)\n. Events:\n.   time amt cmt evid ii addl\n. 1    0 500   1    1  0    0\n. 2   24 250   1    1 24    4\n\nmrgsolve also defines a %then$ operator that lets you execute one event and %then% a second event\n\ne3 %then% e2\n. Events:\n.   time amt ii addl cmt evid\n. 1    0 500 24    0   1    1\n. 2   24 250 24    4   1    1\n\nNotice that e3 has both ii and addl defined. This is required for mrgsolve to know when to start e2.\nCombine to create a data set\nWe can take several event objects and combine them into a single simulation data frame with the as_data_set function.\n\ne1 <- ev(amt=100, ii=24, addl=6, ID=1:5)\ne2 <- ev(amt=50,  ii=12, addl=13, ID=1:3)\ne3 <- ev(amt=200, ii=24, addl=2, ID=1:2)\n\nWhen combined into a data set, we get * N=5 IDs receiving 100 mg Q24h x7 * N=3 IDs receiving 50 mg Q12h x 14 * N=2 IDs receiving 200 mg Q48h x 3\n\ndata <- as_data_set(e1,e2,e3)\ndata\n.    ID time cmt evid amt ii addl\n. 1   1    0   1    1 100 24    6\n. 2   2    0   1    1 100 24    6\n. 3   3    0   1    1 100 24    6\n. 4   4    0   1    1 100 24    6\n. 5   5    0   1    1 100 24    6\n. 6   6    0   1    1  50 12   13\n. 7   7    0   1    1  50 12   13\n. 8   8    0   1    1  50 12   13\n. 9   9    0   1    1 200 24    2\n. 10 10    0   1    1 200 24    2\n\nTo simulate from this data set, we use the data_set function. First, let’s load a population PK model\n\nmod <- mread_cache(\"popex\", modlib())\n\n\nmod %>% data_set(data) %>% mrgsim(end=336) %>% plot(GUT+DV ~  .)\n\n\n\n\n",
    "preview": "posts/2019-01-17-events/distill-preview.png",
    "last_modified": "2022-01-01T09:16:31-06:00",
    "input_file": {}
  },
  {
    "path": "posts/2017-02-01-mixture-model/",
    "title": "Mixture model example",
    "description": "In NONMEM, `$MIXTURE` will allow you to estimate mixture models, where\nindividuals are classified in to two or more populations with \na certain probability. It is straightforward to simulate from models like \nthese in your `mrgsolve` model code.",
    "author": [],
    "date": "2017-02-01",
    "categories": [
      "mixture model"
    ],
    "contents": "\n\nContents\nTwo Populations\nModify the model to simulate a population mixture\n\nThree (or more) Populations\n\nTwo Populations\nLet’s imagine there were two populations in the mixture model, with the second having smaller clearance than the first. In this example, we will develop some code for a simple model and then extend it to implement the mixture model component.\nA simple model might be:\n\nlibrary(mrgsolve)\nlibrary(dplyr)\n\ncode <- '\n$PARAM TVCL = 1, V = 30, KA=1.2, POP = 1, THETA1 = 0.5\n\n$PKMODEL cmt=\"GUT CENT\", depot=TRUE\n\n$MAIN\ndouble CL = TVCL;\n\nif(POP==2) CL = TVCL * THETA1;\n'\n\nIn this model, we created a parameter for the population indicator (POP) and if POP is 2 then clearance is lower than it would be otherwise.\nCompile this model and run\n\nmod <- mcode_cache(\"A\", code) %>% update(end=72, delta=0.1)\n\nidata <- data_frame(POP=c(1,2))\n\ne <- ev(amt=100)\n\nmod %>% mrgsim(idata=idata,events=e) %>% plot\n\n\nThe profile in pink was for POP==2 or the lower clearance profile and blue was for POP==1.\nModify the model to simulate a population mixture\nIn the get-started example model, we hard-coded POP as a parameter and we had to supply the value of POP in the input data set (in this case, it was via idata).\nFor the mixture model, we want POP to be simulated and we want the simulated value to be 1 with a probability of, say, 0.8 and 2 with a probability of 0.2.\nTo make this happen, we need to simulate a binary variate for each individual. Random numbers are easy to simulate with mrgsolve when you use $PLUGIN.\n\ncode <- '\n$PLUGIN Rcpp\n\n$MAIN\nif(NEWIND <=1) {\n  int POP = 1 + R::rbinom(1,0.2);\n}\n\n$CAPTURE POP\n'\n\nmod <- mcode_cache(\"B\", code)\n\nHere, we invoked the Rcpp plugin that allows us to call R::binom(1,0.8). R::binom() is just like the regular R version, but it only draws one variate (n=1).\nLet’s test it out\n\nset.seed(222)\nout <- mrgsim(mod, nid=10000, end=-1)\n\nhead(out)\n.   ID time POP\n. 1  1    0   2\n. 2  2    0   1\n. 3  3    0   1\n. 4  4    0   1\n. 5  5    0   2\n. 6  6    0   2\n\nHere, we’ve got 20% of the people in the population with POP of 2:\n\nmean(out$POP==2)\n. [1] 0.1973\n\nNow, let’s modify the model again to incorporate our random POP calculation with the PK model. I have also included a home-brewed ETA using R::rnorm as another example and to make the summary a little more interesting.\n\ncode <- '\n$PLUGIN Rcpp\n\n$PARAM TVCL = 1, V = 30, KA=1.2, THETA1 = 0.5\n\n$PKMODEL cmt=\"GUT CENT\", depot=TRUE\n\n$MAIN\nif(NEWIND <=1) {\n  int POP = 1 + R::rbinom(1,0.2);\n  double myETA = R::rnorm(0,sqrt(0.09));\n}\n\ndouble CL = TVCL;\n\nif(POP==2) CL = TVCL * THETA1;\n\ndouble CLi = CL*exp(myETA);\n\n$CAPTURE POP CL CLi\n'\n\nmod <- mcode_cache(\"C\", code)\n\nAnd simulate again\n\nset.seed(444)\nout <- mrgsim(mod,nid=10000, end=72, events=e,obsonly=TRUE)\n\n\nhead(out)\n.   ID time        GUT     CENT POP CL       CLi\n. 1  1    0  0.0000000  0.00000   1  1 0.7642753\n. 2  1    1 30.1194212 68.50511   1  1 0.7642753\n. 3  1    2  9.0717953 86.89259   1  1 0.7642753\n. 4  1    3  2.7323722 90.25855   1  1 0.7642753\n. 5  1    4  0.8229747 89.17134   1  1 0.7642753\n. 6  1    5  0.2478752 86.81173   1  1 0.7642753\nmean(out$CL==0.5)\n. [1] 0.1977\n\n\nout %>% \n  filter(time==0) %>%\n  group_by(POP) %>% \n  summarise(N=n(), Median = median(CLi))\n. # A tibble: 2 × 3\n.     POP     N Median\n.   <dbl> <int>  <dbl>\n. 1     1  8023  1.00 \n. 2     2  1977  0.499\n\nThree (or more) Populations\nThere are probably several ways to simulate three populations. Here is one way. We’ll drop the PK model for now and focus on generating POP.\n\ncode <- '\n$PARAM p1 = 0.33, p2 = 0.6\n\n$PLUGIN Rcpp\n\n$MAIN\nif(NEWIND <=1) {\n  double mixv = R::runif(0,1);\n  int POP = 1;\n  if(mixv > p1) POP = 2;\n  if(mixv > (p1+p2)) POP = 3;\n}\n\n$CAPTURE POP mixv\n'\n\nHere’s what we did\nCode mixture probabilities in $PARAM\nDraw a variate (mixv) from uniform(0,1)\nDetermine POP based on the probabilities and mixv\nRemember: you must use $PLUGIN for this to work\nNow, let’s compile and test it out\n\nmod <- mcode_cache(\"D\", code)\n\nset.seed(333)\nout <- mrgsim(mod, nid=10000, end=-1)\n\n\nhead(out)\n.   ID time POP       mixv\n. 1  1    0   2 0.46700066\n. 2  2    0   1 0.08459815\n. 3  3    0   3 0.97348527\n. 4  4    0   2 0.57130558\n. 5  5    0   1 0.02011937\n. 6  6    0   2 0.72355739\n\nAnd check that the population is properly configured\n\nout %>% as_tibble() %>% count(POP) %>% mutate(p = n/nrow(out))\n. # A tibble: 3 × 3\n.     POP     n      p\n.   <dbl> <int>  <dbl>\n. 1     1  3225 0.322 \n. 2     2  6053 0.605 \n. 3     3   722 0.0722\n\nAnd we get back the 33% in population 1, 60% in population 2, and the remaining 7% in population 3.\nAs a final note: remember to call set.seed() prior to simulating anything random with mrgsovle in order for the results to be reproducible.\n\n\n",
    "preview": "posts/2017-02-01-mixture-model/distill-preview.png",
    "last_modified": "2022-01-01T09:05:16-06:00",
    "input_file": {}
  }
]
