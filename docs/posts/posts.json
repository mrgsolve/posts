[
  {
    "path": "posts/2022-01-05-0-12-3-preview/",
    "title": "Coming up in the next version",
    "description": "This article gives a preview of what is to come in the next mrgsolve release.",
    "author": [
      {
        "name": "Kyle Baron",
        "url": "https://github.com/kylebaron"
      }
    ],
    "date": "2022-01-11",
    "categories": [
      "what's new"
    ],
    "contents": "\n\nContents\nUse THETA(n) to refer to THETAn\nNew plugin called autodec\nNew plugin called nm-vars\nNew time spacer for event sequences\nCollapse matrices\n\nThere are a bunch of new features coming up in the next mrgsolve release. Most of these are related to model syntax (what / how you write your model in the .mod or .cpp file) rather than model functionality.\nUse THETA(n) to refer to THETAn\nAll models will be able to use THETA(n) to refer to THETAn. For example:\n\n[ nmxml ] \nrun = 100\nroot = \"cppfile\"\n\n[ main ] \ndouble CL = THETA(1) * pow(WT/70, 0.75);\n\nYou’ll notice that we referred to a nonmem run with [ nmxml ] so this syntax is meant be one small step toward making it easier to translate your model from the nonmem control stream to mrgsolve format. This is pretty simple, but will mean less time removing parentheses when copying over model code.\nNew plugin called autodec\nPlugins are extra functionality that you can invoke when coding your model. For example, plugins exist for calculating time after dose, adding Rcpp functionality to your model etc and more.\nOne new plugin is called autodec. This plugin will automatically declare C++ variables for you. For example, I can code the snipped from the previous block using autodec plugin and mrgsolve will discover that CL needs to be declared:\n\n[ plugin ] autodec\n\n[ nmxml ] \nrun = 100\nroot = \"cppfile\"\n\n[ main ] \nCL = THETA(1) * pow(WT/70, 0.75);\n\nThe motivation behind this feature is to make it easier to code models with lots of variables when all your variables are simple double precision floating point numbers.\nNew plugin called nm-vars\nThis plugin provided a nonmem-like syntax for certain model elements, including\nFn, Dn, Rn, and ALAGn\nA(n), A_0(n) and DADT(n)\nSo your mrgsolve model translated from nonmem might look like this\n\nsee(modlib(\"1005\"))\n\n\n[ PROB ]\n1005 phase1 2 CMT like 1004 but diff. initial on V3\n\nRun \nfile.show(system.file(\"nonmem\", \"1005\", \"1005.ctl\", package = \"mrgsolve\")) \nfor equivalent NONMEM control stream. \n\nUpdated 10 Jan 2022 to use autodec and nm-vars plugins.\n\n[ PLUGIN ] autodec nm-vars\n  \n[ CMT ] @number 3\n  \n[ PKMODEL ] ncmt = 2, depot = TRUE\n\n[ PARAM ] SEX = 0, WT = 70\n\n[ NMXML ] \nproject = system.file(\"nonmem\", package = \"mrgsolve\")\nrun = 1005\n\n[ PK ] \nCL = THETA(1)*exp(ETA(1)) * pow(THETA(6),SEX) * pow(WT/70.0,THETA(7));\nV2 = THETA(2)*exp(ETA(2));\nKA = THETA(3)*exp(ETA(3));\nQ  = THETA(4);\nV3 = THETA(5);\nS2 = V2;\n\n[ ERROR ] \nF = A2/S2;\nY = F*(1+EPS(1)) + EPS(2); \nIPRED = F; \n\n[ CAPTURE ]\nCL Q V2 V3 KA ETA(1) ETA(2) ETA(3) IPRED\n\nwhere I updated the internal model 1005 to reflect use of both autodec and nm-vars plugins.\nNotice that not all nonmem syntax is supported; just select data structures that use A and DADT to refer to compartments and differential equations. Also notice that we still require ; at the end of each line and we still need to use pow(base, exponent) to calculate exponent of some number.\nI’ll have full documentation in the user guide once the release is made.\nNew time spacer for event sequences\nThe new feature is an ii spacer for sequences of event objects.\nUsing event objects, we can create complicated dosing regimens from simpler ones. For example, we might have a week of 50 mg dosing followed by a week of 100 mg dosing and then up to 200 mg dosing. We can accomplish that with an event sequence\nFirst create the individual pieces\n\na <- ev(amt = 50,  ii = 24, addl = 6)\nb <- ev(amt = 100, ii = 24, addl = 6)\nc <- ev(amt = 200, ii = 24, addl = 6)\n\nThen put them in a sequence\n\ndata <- ev_seq(a, b, c)\ndata\nEvents:\n  time amt ii addl cmt evid\n1    0  50 24    6   1    1\n2  168 100 24    6   1    1\n3  336 200 24    6   1    1\n\nWhen they are sequenced, you’ll see that the second piece (b) starts one dosing interval after the last dose in the first piece (a).\nWe can put a 24 hour spacer between a and b\n\nseq(a, wait = 24, b)\nEvents:\n  time amt ii addl cmt evid\n1    0  50 24    6   1    1\n2  192 100 24    6   1    1\n\nHere, the last dose in a is given, we wait one dosing interval (24 hours) then wait another 24 hours (via wait) and then start b.\nRather than using wait, we can use ii to specify the amount of time from the last dose in a to the first dose in b. So if we want to wait 3 days between the last dose in a and the first dose in b\n\nev_seq(a, ii = 3*24, b)\nEvents:\n  time amt ii addl cmt evid\n1    0  50 24    6   1    1\n2  216 100 24    6   1    1\n\nNotice that this same behavior can be achieved with wait but using ii might be easier to interpret in some cases.\nCollapse matrices\nSometimes in your model, you have multiple OMEGA or SIGMA blocks like this\n\ncode <- '\n$OMEGA  @name first\n1 2 3\n\n$OMEGA @name second\n4\n'\nmod <- mcode(\"collapse\", code, compile = FALSE)\n\nomat(mod)\n$first\n    [,1] [,2] [,3]\n1:     1    0    0\n2:     0    2    0\n3:     0    0    3\n\n$second\n    [,1]\n4:     4\n\nIf I want to update these values but I only have a 4x4 matrix\n\nmat\n     [,1] [,2] [,3] [,4]\n[1,]  0.1  0.0  0.0  0.0\n[2,]  0.0  0.2  0.0  0.0\n[3,]  0.0  0.0  0.3  0.0\n[4,]  0.0  0.0  0.0  0.4\n\nI can’t do it; mrgsolve wants a 3x3 matrix for the first slot and 1x1 matrix for the second.\nA new function will collapse the model matrix into larger matrices\n\nmod <- collapse_omega(mod)\nomat(mod)\n$...\n    [,1] [,2] [,3] [,4]\n1:     1    0    0    0\n2:     0    2    0    0\n3:     0    0    3    0\n4:     0    0    0    4\n\n\nmod <- update(mod, omat = mat)\nomat(mod)\n$...\n    [,1] [,2] [,3] [,4]\n1:     1    0    0    0\n2:     0    2    0    0\n3:     0    0    3    0\n4:     0    0    0    4\n\nYou can’t split matrices up into smaller chunks, but if there are more than two blocks, you can select which blocks to join\n\ncode <- '\n$OMEGA  @name first\n1 2 3\n\n$OMEGA @name second\n4\n\n$OMEGA @name third\n5 6 7 8\n'\nmod <- mcode(\"collapse2\", code, compile = FALSE)\n\nomat(mod)\n$first\n    [,1] [,2] [,3]\n1:     1    0    0\n2:     0    2    0\n3:     0    0    3\n\n$second\n    [,1]\n4:     4\n\n$third\n    [,1] [,2] [,3] [,4]\n5:     5    0    0    0\n6:     0    6    0    0\n7:     0    0    7    0\n8:     0    0    0    8\nmod <- collapse_omega(mod, range = c(2, NA), name = \"remainder\")\nomat(mod)\n$first\n    [,1] [,2] [,3]\n1:     1    0    0\n2:     0    2    0\n3:     0    0    3\n\n$remainder\n    [,1] [,2] [,3] [,4] [,5]\n4:     4    0    0    0    0\n5:     0    5    0    0    0\n6:     0    0    6    0    0\n7:     0    0    0    7    0\n8:     0    0    0    0    8\n\n\n\n",
    "preview": {},
    "last_modified": "2022-01-11T13:49:55-06:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-05-11-new-0-11-0/",
    "title": "New in 0.11.0 and 0.11.1",
    "description": "Changes and new features for mrgsolve versions 0.11.0 and 0.11.1.",
    "author": [],
    "date": "2021-05-11",
    "categories": [
      "what's new"
    ],
    "contents": "\n\nContents\nDynamic capture\nSee model variables\nWhy would I use this???\n\nSimulate with negative times\nPath to NM results using NMEXT and NMXML\nRoot path\nSelect table number in NMEXT\nReveal results file\n\nProgrammatic block initialization\nCheck User Interrupt\n\nDynamic capture\nThis is one of my favorite new features. I’ve written about it before, but as a review: we added a capture argument to mread() so you can opt in to capture additional model variables in the simulated output.\nFor example, let’s look at this model:\n\nmod <- modlib(\"irm1\")\noutvars(mod)\n. $cmt\n. [1] \"EV1\"    \"CENT\"   \"PERIPH\" \"RESP\"   \"EV2\"   \n. \n. $capture\n. [1] \"CP\"\n\nYou can see the compartments (cmt) and other model variables that are getting captured (capture).\nSee model variables\nWe can now look into the model and see which variables are available to capture. First, coerce mod to a list() and then look at the cpp_variables item:\n\ncpp_variables <- as.list(mod)$cpp_variables\ncpp_variables\n.     type  var context\n. 1 define   CP  global\n. 2 define   CT  global\n. 3 define CLNL  global\n. 4 define  INH  global\n\nThis tells us what we could capture. Now that we have the information, let’s capture everything possible:\n\nmod <- modlib(\"irm1\", capture = cpp_variables$var)\n\nNow, everything is getting captured:\n\noutvars(mod)\n. $cmt\n. [1] \"EV1\"    \"CENT\"   \"PERIPH\" \"RESP\"   \"EV2\"   \n. \n. $capture\n. [1] \"CP\"   \"CT\"   \"CLNL\" \"INH\"\n\nand will appear in the simulated output:\n\nmrgsim(mod, events = ev(amt = 100), param = list(VMAX  = 2))\n. Model:  irm1 \n. Dim:    26 x 11 \n. Time:   0 to 24 \n. ID:     1 \n.     ID time      EV1  CENT PERIPH  RESP EV2    CP     CT   CLNL\n. 1:   1    0   0.0000  0.00  0.000 5.000   0 0.000 0.0000 1.0000\n. 2:   1    0 100.0000  0.00  0.000 5.000   0 0.000 0.0000 1.0000\n. 3:   1    1  36.7879 57.40  3.221 2.837   0 2.870 0.3221 0.4107\n. 4:   1    2  13.5335 70.69  8.641 1.988   0 3.534 0.8641 0.3614\n. 5:   1    3   4.9787 69.58 13.484 1.834   0 3.479 1.3484 0.3650\n. 6:   1    4   1.8316 64.48 17.119 1.875   0 3.224 1.7119 0.3828\n. 7:   1    5   0.6738 58.87 19.596 1.970   0 2.943 1.9596 0.4046\n. 8:   1    6   0.2479 53.77 21.135 2.078   0 2.689 2.1135 0.4266\n.        INH\n. 1:  0.0000\n. 2:  0.0000\n. 3:  0.5893\n. 4:  0.6386\n. 5:  0.6350\n. 6:  0.6172\n. 7:  0.5954\n. 8:  0.5734\n\nIn this example, we could choose from a bunch of pre-processor directives, but the only reason for that is this is the way the model was coded. We can look at another example:\n\nmod <- modlib(\"pbpk\")\nas.list(mod)$cpp_variables %>% head()\n.     type var context\n. 1 double Vad    main\n. 2 double Vbo    main\n. 3 double Vbr    main\n. 4 double Vgu    main\n. 5 double Vhe    main\n. 6 double Vki    main\n\nWhy would I use this???\nHere’s an example: I have a covariate model going and I want to get parameter values given some covariates. I can write:\n\nmod <- modlib(\"popex\", capture = \"CL,V,KA\") %>% zero_re()\n\nidata <- tibble(WT = seq(40,140,5))\n\nmrgsim(mod, idata = idata, end = -1)\n. Model:  popex \n. Dim:    21 x 10 \n. Time:   0 to 0 \n. ID:     21 \n.     ID time GUT CENT ECL IPRED DV     CL     V  KA\n. 1:   1    0   0    0   0     0  0 0.6572 13.71 0.5\n. 2:   2    0   0    0   0     0  0 0.7179 15.43 0.5\n. 3:   3    0   0    0   0     0  0 0.7770 17.14 0.5\n. 4:   4    0   0    0   0     0  0 0.8345 18.86 0.5\n. 5:   5    0   0    0   0     0  0 0.8908 20.57 0.5\n. 6:   6    0   0    0   0     0  0 0.9459 22.29 0.5\n. 7:   7    0   0    0   0     0  0 1.0000 24.00 0.5\n. 8:   8    0   0    0   0     0  0 1.0531 25.71 0.5\n\nNow, I have CL, V and KA all calculated as a function of WT.\nSimulate with negative times\nUntil 0.11.0, it was an error whenever negative times were requested in the simulation. Now, negative times are accepted without error.Keep in mind that the data set still needs to be sorted by time when passing data.\nAs an example:\n\nmod <- modlib(\"irm2\") %>% param(KOUT = 0.05)\n\nsims <- \n  mod %>% \n  ev(amt = 100, ii = 48, addl = 1) %>% \n  mrgsim(start = -72, end = 240) \n\nsims\n. Model:  irm2 \n. Dim:    314 x 8 \n. Time:   -72 to 240 \n. ID:     1 \n.     ID time EV1 CENT PERIPH RESP EV2 CP\n. 1:   1  -72   0    0      0  200   0  0\n. 2:   1  -71   0    0      0  200   0  0\n. 3:   1  -70   0    0      0  200   0  0\n. 4:   1  -69   0    0      0  200   0  0\n. 5:   1  -68   0    0      0  200   0  0\n. 6:   1  -67   0    0      0  200   0  0\n. 7:   1  -66   0    0      0  200   0  0\n. 8:   1  -65   0    0      0  200   0  0\nplot(sims, \"EV1 CP RESP\")\n\n\nPath to NM results using NMEXT and NMXML\nThis is pretty subtle issue but I’ve grown very sensitive to it recently and decided we needed to change this.\nWhen you use the $NMEXT or $NMXML blocks, you are asking mrgsolve to import THETA, OMEGA and / or SIGMA from a completed NONMEM run. And we need to specify the path to those results.\nSo far, we have had you typically specify the path relative to the current working directory. This was ok, but problems happened if you wanted to use the model from a different working directory (you’d get an error).\nSo we added an argument called root to $NMEXT and $NMXML that lets you change how that path is interpreted.\nRoot path\nThe current default behavior is to interpret the path relative to the current working directory:\n\n[ nmext ] \nrun = 1001\nproject = \"../model/nonmem\"\n\nThis is equivalent to invoking the new root argument and setting it to \"working\":\n\n[ nmext ] \nrun = 1001\nproject = \"../model/nonmem\"\nroot = \"working\"\n\nI am encouraging you to start setting this root argument to \"cppfile\" which tells mrgsolve to interpret the path relative to wherever the model code is located:\n\n[ nmext ] \nrun = 1001\nproject = \"../model/nonmem\"\nroot = \"cppfile\"\n\nWhen you do this, you can load this model from any working directory as long as the file remains in the same location. I am encouraging you to start using this because I think we will eventually make \"cppfile\" the default root because it makes so much more sense.\nNote that you can always specify an absolute path here and in that case, it doesn’t matter what you use for the root argument (see the discussion on here() in the following section).\nWith here()\nSome are also using the here::here() function. This is totally independent of any mrgsolve functionality, but here() will return the absolute path relative to your Rstudio project root. So, if all my models were in the model/nonmem directory, I can always get the absolute path using here() regardless of the working directory and regardless of where the cpp file is located.\n\n[ nmext ] \nrun = 1001\nproject = here::here(\"model/nonmem\")\n\nNote here that the argument / options here are evaluated by the R interpreter so that the here() call resolves to the correct project directory.\nSelect table number in NMEXT\nThe [ nmext ] block gains an index argument that will let you select which table in the .ext file to import from when there are multiple.\nthe default is last\notherwise, pass an integer (e.g. 1 for first, 3 for 3rd)\nsee the ?nmext help topic for more info on this and other argument / options for the nmxml block\nTo select the 2nd table:\n\n[ nmext ] \nrun = 1001\nproject = \"../model/nonmem\"\nroot = \"cppfile\"\nindex = 2 \n\nThe default is to select the last table:\n\n[ nmext ] \nrun = 1001\nproject = \"../model/nonmem\"\nroot = \"cppfile\"\nindex = \"last\" // \"first\"\n\nReveal results file\nWhen you import nonmem results from an .ext file (via [nmext]) or an .xml file (via [nmxml]), the source file is now saved in the model object so that it can be checked later.\nThe internal model library contains an embedded nonmem run numbered 1005; this run imports THETA, OMEGA and SIGMA from a finished nonmem run. You can load this model with the modlib() function.\n\nmod <- modlib(\"1005\")\n\nBy coercing the model to list and checking the nm_import item, you’ll get a character vector with the full (absolute) path to either the .ext or .xml file that was imported from\n\nas.list(mod)$nm_import\n. [1] \"/Users/kyleb/Rlibs/mrgsolve/nonmem/1005/1005.xml\"\n\nProgrammatic block initialization\nI don’t expect you’ll be using this much but when you need it it will come in handy.\nFor example, let’s say you wanted to write a model with a 30 x 30 omega matrix. This would be a pain to code given the current syntax for $OMEGA. I recently refactored and standardized the way you can initialize this block programmatically.\n\ncode <- '\n$OMEGA @as_object\nmatrix(0, nrow = 30, ncol = 30)\n'\nmod <- mcode(\"omega\", code, compile = FALSE)\n\nomat(mod)\n\nWe didn’t run the code because the screen would fill up, but you can try it. You will see that $OMEGA is a 30 x 30 matrix and it was easy to code. Obviously, you’ll have to update this with all the elements but we have given you the ability to easily initialize this matrix.\nIn the example, we used the @as_object directive. The other way to do it would be to create the object in $ENV and then use @object:\n\n$ENV\nfoo <- matrix(0, nrow = 30, ncol = 30)\n\n$OMEGA @object foo\n\nWith this approach, use @object and then name the object that you want to use to populate the block.\nOther blocks that you can use this programmatic initialization:\n$SIGMA - return a matrix\n$CMT - return a character vector of compartment names\n$INIT - return a named list\n$PARAM - return a named list\n$THETA - return a numeric vector\n$FIXED - return a named list\nFor example:\n\ncode <- '\n$PARAM @as_object\nx <- seq(1,26)\nnames(x) <- letters\nas.list(x)\n'\nmod <- mcode(\"letters\", code, compile = FALSE)\nparam(mod)\n. \n.  Model parameters (N=26):\n.  name value . name value\n.  a    1     | n    14   \n.  b    2     | o    15   \n.  c    3     | p    16   \n.  d    4     | q    17   \n.  e    5     | r    18   \n.  f    6     | s    19   \n.  g    7     | t    20   \n.  h    8     | u    21   \n.  i    9     | v    22   \n.  j    10    | w    23   \n.  k    11    | x    24   \n.  l    12    | y    25   \n.  m    13    | z    26\n\nCheck User Interrupt\nStarting with version 0.11.1, we will start periodically checking for the user interrupt signal (Esc or Control-C) as the simulation proceeds. This will let you kill a long-running simulation mid-stream. You can change the check interval by the interrupt argument to mrgsim(). Reduce the number to check more frequently and pass -1 to not check at all.\n\n\n",
    "preview": "posts/2021-05-11-new-0-11-0/distill-preview.png",
    "last_modified": "2022-01-11T12:25:00-06:00",
    "input_file": {}
  },
  {
    "path": "posts/2020-12-20-recover/",
    "title": "Recover non-numeric data columns from data/idata sets",
    "description": "For a long time, we've had `carry_out`, which copies numeric input data set \nitems into your simulated output. Now, `recover` does the same thing but will\ncarry any data type from the input to output data.",
    "author": [],
    "date": "2020-12-20",
    "categories": [
      "new feature"
    ],
    "contents": "\n\nContents\nExample - event objects\nExample - data set\nWhat is the difference: carry_out / recover\n\nWe frequently want to access in the simulated output data items that were present in input data sets. For example, if we have multiple studies represented in the data, we’d like to simulate all studies and then summarize or plot the results by study. We need to study number in the simulated output to do that.\nFor a long time, mrgsolve has had a carry_out feature, where input data columns can be selected and those input data automatically copied to the simulated (output) data. However, this has been limited to numeric data items.\nStarting with mrgsolve version 0.10.4, users can bring non-numeric data items from input data to output. This feature is called recover.\nExample - event objects\n\nlibrary(tidyverse)\nlibrary(mrgsolve)\n\nmod <- house(delta = 0.1, end = 96, outvars = \"CP\")\n\nAs a very simple example, we’ll make an event object with a regimen item in it\n\nqd <- ev_rx(\"100 q24 x3\") %>% mutate(regimen = \"100 mg qd\")\n\nqd\n. Events:\n.   time amt ii addl cmt evid   regimen\n. 1    0 100 24    2   1    1 100 mg qd\n\nWhen I simulate with this event object, I’ll recover the regimen item\n\nout <- mrgsim(mod, qd, recover = \"regimen\")\n\nI now have the “regimen” in the simulated output as a character data item:\n\nplot(out, CP ~ time |regimen)\n\n\n\nas_tibble(out)\n. # A tibble: 962 × 4\n.       ID  time    CP regimen  \n.    <dbl> <dbl> <dbl> <chr>    \n.  1     1   0   0     100 mg qd\n.  2     1   0   0     100 mg qd\n.  3     1   0.1 0.564 100 mg qd\n.  4     1   0.2 1.06  100 mg qd\n.  5     1   0.3 1.50  100 mg qd\n.  6     1   0.4 1.89  100 mg qd\n.  7     1   0.5 2.23  100 mg qd\n.  8     1   0.6 2.52  100 mg qd\n.  9     1   0.7 2.79  100 mg qd\n. 10     1   0.8 3.02  100 mg qd\n. # … with 952 more rows\n\nNow, make another group and simulate together\n\nbid <- ev_rx(\"50 q12 x6\") %>% mutate(regimen = \"50 mg bid\")\n\ndata <- as_data_set(bid,qd) \n\nI’m going to turn this into a factor now …\n\ndata <- mutate(data, regimen = fct_inorder(regimen))\ndata\n.   ID time cmt evid amt ii addl   regimen\n. 1  1    0   1    1  50 12    5 50 mg bid\n. 2  2    0   1    1 100 24    2 100 mg qd\n\n… so that when I summarize, the levels are in the order I want:\n\nout <- mrgsim(mod, data, recover = \"regimen\") \n\nout %>%\n  group_by(regimen) %>% \n  summarise(Cmax = max(CP))\n. # A tibble: 2 × 2\n.   regimen    Cmax\n.   <fct>     <dbl>\n. 1 50 mg bid  4.85\n. 2 100 mg qd  6.15\n\n\nplot(out, CP~time|regimen, scales=\"same\", col = \"black\")\n\n\nExample - data set\nThere is no real change if I’m using recover with a data set\n\nhead(data)\n.    C NUM ID SUBJ TIME SEQ CMT EVID AMT      DV   AGE    WT   CRCL ALB\n. 1 NA   1  1    1 0.00   0   1    1   5   0.000 28.03 55.16 114.45 4.4\n. 2 NA   2  1    1 0.61   1   2    0  NA  61.005 28.03 55.16 114.45 4.4\n. 3 NA   3  1    1 1.15   1   2    0  NA  90.976 28.03 55.16 114.45 4.4\n. 4 NA   4  1    1 1.73   1   2    0  NA 122.210 28.03 55.16 114.45 4.4\n. 5 NA   5  1    1 2.15   1   2    0  NA 126.090 28.03 55.16 114.45 4.4\n. 6 NA   6  1    1 3.19   1   2    0  NA  84.682 28.03 55.16 114.45 4.4\n.     BMI    AAG  SCR   AST   ALT     HT CP TAFD  TAD LDOS MDV BLQ\n. 1 21.67 106.36 1.14 11.88 12.66 159.55  0 0.00 0.00    5   1   0\n. 2 21.67 106.36 1.14 11.88 12.66 159.55  0 0.61 0.61    5   0   0\n. 3 21.67 106.36 1.14 11.88 12.66 159.55  0 1.15 1.15    5   0   0\n. 4 21.67 106.36 1.14 11.88 12.66 159.55  0 1.73 1.73    5   0   0\n. 5 21.67 106.36 1.14 11.88 12.66 159.55  0 2.15 2.15    5   0   0\n. 6 21.67 106.36 1.14 11.88 12.66 159.55  0 3.19 3.19    5   0   0\n.   PHASE STUDY   RF       SEQ_f EVID_f MDV_f   BLQ_f PHASE_f  RENAL\n. 1     1   SAD norm observation      1     1 below Q       1 Normal\n. 2     1   SAD norm        dose      0     0 below Q       1 Normal\n. 3     1   SAD norm        dose      0     0 below Q       1 Normal\n. 4     1   SAD norm        dose      0     0 below Q       1 Normal\n. 5     1   SAD norm        dose      0     0 below Q       1 Normal\n. 6     1   SAD norm        dose      0     0 below Q       1 Normal\n.   HEPATIC\n. 1  normal\n. 2  normal\n. 3  normal\n. 4  normal\n. 5  normal\n. 6  normal\n\nSame idea as we had in event object\n\nout <- mrgsim(mod, data, recover = \"WT,CRCL,STUDY,HEPATIC,RENAL\")\n\nWe copy either numeric, character, or factors into the output\n\nas_tibble(out)\n. # A tibble: 4,360 × 8\n.       ID  TIME    CP    WT  CRCL STUDY HEPATIC RENAL \n.    <dbl> <dbl> <dbl> <dbl> <dbl> <fct> <fct>   <fct> \n.  1     1  0    0      55.2  114. SAD   normal  Normal\n.  2     1  0.61 0.162  55.2  114. SAD   normal  Normal\n.  3     1  1.15 0.229  55.2  114. SAD   normal  Normal\n.  4     1  1.73 0.261  55.2  114. SAD   normal  Normal\n.  5     1  2.15 0.271  55.2  114. SAD   normal  Normal\n.  6     1  3.19 0.273  55.2  114. SAD   normal  Normal\n.  7     1  4.21 0.263  55.2  114. SAD   normal  Normal\n.  8     1  5.09 0.253  55.2  114. SAD   normal  Normal\n.  9     1  6.22 0.238  55.2  114. SAD   normal  Normal\n. 10     1  8.09 0.216  55.2  114. SAD   normal  Normal\n. # … with 4,350 more rows\n\nAnd we can summarize\n\nout %>% \n  filter(TIME < 24) %>%\n  group_by(STUDY,HEPATIC,RENAL) %>%\n  summarise(Cmax = max(CP))\n. # A tibble: 10 × 4\n. # Groups:   STUDY, HEPATIC [7]\n.    STUDY   HEPATIC RENAL     Cmax\n.    <fct>   <fct>   <fct>    <dbl>\n.  1 SAD     normal  Normal    9.53\n.  2 MAD     normal  Normal    5.52\n.  3 Renal   normal  Normal    1.60\n.  4 Renal   normal  Mild      1.59\n.  5 Renal   normal  Moderate  1.95\n.  6 Renal   normal  Severe    1.54\n.  7 Hepatic normal  Normal    1.47\n.  8 Hepatic Pugh1   Normal    1.40\n.  9 Hepatic Pugh2   Normal    1.28\n. 10 Hepatic Pugh3   Normal    1.45\n\n\nsims <- as_tibble(out)\n\nggplot(sims, aes(TIME,CP,group=ID)) + \n  facet_grid(STUDY~RENAL) + \n  geom_line() + theme_bw()\n\n\nWhat is the difference: carry_out / recover\nThere should not be a difference in the simulation result whether you use carry_out or recover (outside of the fact that recover takes any type of data).\nThere will be a very minor performance hit for using recover because it has to join the input data on to the simulated data. But this should be imperceptible in the vast majority of cases. Of course, when every microsecond of simulation time counts, think carefully about what you are doing and consider more efficient alternatives. Remember that features like carry_out and recover are convenience features to make you life easier. They always increase the overall simulation time to some degree or another. So when benchmarking mrgsolve, you should always consider if carry_out or recover are being used or not.\nrecover depends on carry_out functionality to work: under the hood, we label the input data rows with an index number, carry_out that index, and then use that index to join input to output data. So carry_out won’t go away. But I’m guessing that recover will be fine for most applications.\nGoing forward, I will be adding other convenience functions around recover and working to make it a more convenient part of your workflow.\n\n\n",
    "preview": "posts/2020-12-20-recover/distill-preview.png",
    "last_modified": "2022-01-04T18:01:37-06:00",
    "input_file": {}
  },
  {
    "path": "posts/2019-01-17-events/",
    "title": "Work with event objects",
    "description": "Event objects are a simple way to implement dosing or other interventions\ninto your simulation. They are created with special constructors and elementary\nevents can be combined in different ways to create complex dosing regimens.",
    "author": [],
    "date": "2019-01-17",
    "categories": [
      "events"
    ],
    "contents": "\n\nContents\nIntroduction\nSetup\nEvents\nEvent expectations\nCombine events\nCombine to create a data set\n\nIntroduction\nEvent objects are simple ways to implement PK dosing events into your model simulation.\nSetup\nLet’s illustrate event objects with a one-compartment, PK model. We read this model from the mrgsolve internal model library.\n\nlibrary(mrgsolve)\nlibrary(dplyr)\noptions(mrgsolve.soloc = \"build\")\n\n\nmod <- mread_cache(\"pk1cmt\", modlib(), end=216, delta=0.1)\n\nEvents\nEvents are constructed with the ev function\n\ne <- ev(amt=100, ii=24, addl=6)\n\nThis will implement 100 unit doses every 24 hours for a total of 7 doses. e has class ev, but really it is just a data frame\n\ne\n. Events:\n.   time amt ii addl cmt evid\n. 1    0 100 24    6   1    1\n\n\nas.data.frame(e)\n.   time amt ii addl cmt evid\n. 1    0 100 24    6   1    1\n\nWe can implement this series of doses by passing e in as the events argument to mrgsim()\n\nmod %>% mrgsim(events=e) %>% plot(EV1+CP~time)\n\n\nThe events can also be implemented with the ev constructor along the simulation pipeline\n\nmod %>%\n  ev(amt = 100, ii = 24, addl = 6) %>%\n  mrgsim %>% \n  plot(CP~time)\n\n\nEvent expectations\namt is required\nevid=0 is forbidden\nDefault time is 0\nDefault evid is 1\nDefault cmt is 1\nAlso by default, rate, ss and ii are 0.\nCombine events\nmrgsolve has operators defined that allow you to combine events. Let’s first define some event objects.\n\ne1 <- ev(amt=500)\ne2 <- ev(amt=250, ii=24, addl=4)\ne3 <- ev(amt=500, ii=24, addl=0)\ne4 <- ev(amt=250, ii=24, addl=4, time=24)\n\nWe can combine e1 and e3 with a collection operator\n\nc(e1,e4)\n. Events:\n.   time amt cmt evid ii addl\n. 1    0 500   1    1  0    0\n. 2   24 250   1    1 24    4\n\nmrgsolve also defines a %then$ operator that lets you execute one event and %then% a second event\n\ne3 %then% e2\n. Events:\n.   time amt ii addl cmt evid\n. 1    0 500 24    0   1    1\n. 2   24 250 24    4   1    1\n\nNotice that e3 has both ii and addl defined. This is required for mrgsolve to know when to start e2.\nCombine to create a data set\nWe can take several event objects and combine them into a single simulation data frame with the as_data_set function.\n\ne1 <- ev(amt=100, ii=24, addl=6, ID=1:5)\ne2 <- ev(amt=50,  ii=12, addl=13, ID=1:3)\ne3 <- ev(amt=200, ii=24, addl=2, ID=1:2)\n\nWhen combined into a data set, we get * N=5 IDs receiving 100 mg Q24h x7 * N=3 IDs receiving 50 mg Q12h x 14 * N=2 IDs receiving 200 mg Q48h x 3\n\ndata <- as_data_set(e1,e2,e3)\ndata\n.    ID time cmt evid amt ii addl\n. 1   1    0   1    1 100 24    6\n. 2   2    0   1    1 100 24    6\n. 3   3    0   1    1 100 24    6\n. 4   4    0   1    1 100 24    6\n. 5   5    0   1    1 100 24    6\n. 6   6    0   1    1  50 12   13\n. 7   7    0   1    1  50 12   13\n. 8   8    0   1    1  50 12   13\n. 9   9    0   1    1 200 24    2\n. 10 10    0   1    1 200 24    2\n\nTo simulate from this data set, we use the data_set function. First, let’s load a population PK model\n\nmod <- mread_cache(\"popex\", modlib())\n\n\nmod %>% data_set(data) %>% mrgsim(end=336) %>% plot(GUT+DV ~  .)\n\n\n\n\n",
    "preview": "posts/2019-01-17-events/distill-preview.png",
    "last_modified": "2022-01-04T18:02:12-06:00",
    "input_file": {}
  },
  {
    "path": "posts/2017-02-01-mixture-model/",
    "title": "Mixture model example",
    "description": "In NONMEM, `$MIXTURE` will allow you to estimate mixture models, where\nindividuals are classified in to two or more populations with \na certain probability. It is straightforward to simulate from models like \nthese in your `mrgsolve` model code.",
    "author": [],
    "date": "2017-02-01",
    "categories": [
      "mixture model"
    ],
    "contents": "\n\nContents\nTwo Populations\nModify the model to simulate a population mixture\n\nThree (or more) Populations\n\nTwo Populations\nLet’s imagine there were two populations in the mixture model, with the second having smaller clearance than the first. In this example, we will develop some code for a simple model and then extend it to implement the mixture model component.\nA simple model might be:\n\nlibrary(mrgsolve)\nlibrary(dplyr)\n\ncode <- '\n$PARAM TVCL = 1, V = 30, KA=1.2, POP = 1, THETA1 = 0.5\n\n$PKMODEL cmt=\"GUT CENT\", depot=TRUE\n\n$MAIN\ndouble CL = TVCL;\n\nif(POP==2) CL = TVCL * THETA1;\n'\n\nIn this model, we created a parameter for the population indicator (POP) and if POP is 2 then clearance is lower than it would be otherwise.\nCompile this model and run\n\nmod <- mcode_cache(\"A\", code) %>% update(end=72, delta=0.1)\n\nidata <- data_frame(POP=c(1,2))\n\ne <- ev(amt=100)\n\nmod %>% mrgsim(idata=idata,events=e) %>% plot\n\n\nThe profile in pink was for POP==2 or the lower clearance profile and blue was for POP==1.\nModify the model to simulate a population mixture\nIn the get-started example model, we hard-coded POP as a parameter and we had to supply the value of POP in the input data set (in this case, it was via idata).\nFor the mixture model, we want POP to be simulated and we want the simulated value to be 1 with a probability of, say, 0.8 and 2 with a probability of 0.2.\nTo make this happen, we need to simulate a binary variate for each individual. Random numbers are easy to simulate with mrgsolve when you use $PLUGIN.\n\ncode <- '\n$PLUGIN Rcpp\n\n$MAIN\nif(NEWIND <=1) {\n  int POP = 1 + R::rbinom(1,0.2);\n}\n\n$CAPTURE POP\n'\n\nmod <- mcode_cache(\"B\", code)\n\nHere, we invoked the Rcpp plugin that allows us to call R::binom(1,0.8). R::binom() is just like the regular R version, but it only draws one variate (n=1).\nLet’s test it out\n\nset.seed(222)\nout <- mrgsim(mod, nid=10000, end=-1)\n\nhead(out)\n.   ID time POP\n. 1  1    0   2\n. 2  2    0   1\n. 3  3    0   1\n. 4  4    0   1\n. 5  5    0   2\n. 6  6    0   2\n\nHere, we’ve got 20% of the people in the population with POP of 2:\n\nmean(out$POP==2)\n. [1] 0.1973\n\nNow, let’s modify the model again to incorporate our random POP calculation with the PK model. I have also included a home-brewed ETA using R::rnorm as another example and to make the summary a little more interesting.\n\ncode <- '\n$PLUGIN Rcpp\n\n$PARAM TVCL = 1, V = 30, KA=1.2, THETA1 = 0.5\n\n$PKMODEL cmt=\"GUT CENT\", depot=TRUE\n\n$MAIN\nif(NEWIND <=1) {\n  int POP = 1 + R::rbinom(1,0.2);\n  double myETA = R::rnorm(0,sqrt(0.09));\n}\n\ndouble CL = TVCL;\n\nif(POP==2) CL = TVCL * THETA1;\n\ndouble CLi = CL*exp(myETA);\n\n$CAPTURE POP CL CLi\n'\n\nmod <- mcode_cache(\"C\", code)\n\nAnd simulate again\n\nset.seed(444)\nout <- mrgsim(mod,nid=10000, end=72, events=e,obsonly=TRUE)\n\n\nhead(out)\n.   ID time        GUT     CENT POP CL       CLi\n. 1  1    0  0.0000000  0.00000   1  1 0.7642753\n. 2  1    1 30.1194212 68.50511   1  1 0.7642753\n. 3  1    2  9.0717953 86.89259   1  1 0.7642753\n. 4  1    3  2.7323722 90.25855   1  1 0.7642753\n. 5  1    4  0.8229747 89.17134   1  1 0.7642753\n. 6  1    5  0.2478752 86.81173   1  1 0.7642753\nmean(out$CL==0.5)\n. [1] 0.1977\n\n\nout %>% \n  filter(time==0) %>%\n  group_by(POP) %>% \n  summarise(N=n(), Median = median(CLi))\n. # A tibble: 2 × 3\n.     POP     N Median\n.   <dbl> <int>  <dbl>\n. 1     1  8023  1.00 \n. 2     2  1977  0.499\n\nThree (or more) Populations\nThere are probably several ways to simulate three populations. Here is one way. We’ll drop the PK model for now and focus on generating POP.\n\ncode <- '\n$PARAM p1 = 0.33, p2 = 0.6\n\n$PLUGIN Rcpp\n\n$MAIN\nif(NEWIND <=1) {\n  double mixv = R::runif(0,1);\n  int POP = 1;\n  if(mixv > p1) POP = 2;\n  if(mixv > (p1+p2)) POP = 3;\n}\n\n$CAPTURE POP mixv\n'\n\nHere’s what we did\nCode mixture probabilities in $PARAM\nDraw a variate (mixv) from uniform(0,1)\nDetermine POP based on the probabilities and mixv\nRemember: you must use $PLUGIN for this to work\nNow, let’s compile and test it out\n\nmod <- mcode_cache(\"D\", code)\n\nset.seed(333)\nout <- mrgsim(mod, nid=10000, end=-1)\n\n\nhead(out)\n.   ID time POP       mixv\n. 1  1    0   2 0.46700066\n. 2  2    0   1 0.08459815\n. 3  3    0   3 0.97348527\n. 4  4    0   2 0.57130558\n. 5  5    0   1 0.02011937\n. 6  6    0   2 0.72355739\n\nAnd check that the population is properly configured\n\nout %>% as_tibble() %>% count(POP) %>% mutate(p = n/nrow(out))\n. # A tibble: 3 × 3\n.     POP     n      p\n.   <dbl> <int>  <dbl>\n. 1     1  3225 0.322 \n. 2     2  6053 0.605 \n. 3     3   722 0.0722\n\nAnd we get back the 33% in population 1, 60% in population 2, and the remaining 7% in population 3.\nAs a final note: remember to call set.seed() prior to simulating anything random with mrgsovle in order for the results to be reproducible.\n\n\n",
    "preview": "posts/2017-02-01-mixture-model/distill-preview.png",
    "last_modified": "2022-01-04T18:02:05-06:00",
    "input_file": {}
  }
]
